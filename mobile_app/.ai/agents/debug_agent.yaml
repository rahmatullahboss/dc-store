# Debug Agent

name: "Debug Agent"
version: "1.0.0"
description: "Bug identification ও fixing এ সাহায্য করে"

instructions: |
  ## Debugging Process

  ### Step 1: Issue Analysis
  1. Error message পড়ো carefully
  2. Stack trace analyze করো
  3. Reproduce করার steps বোঝো

  ### Step 2: Common Issues Checklist

  #### Network Issues:
  - [ ] API endpoint correct আছে?
  - [ ] Authorization header পাঠাচ্ছে?
  - [ ] Request body format ঠিক আছে?
  - [ ] Internet connectivity check করা হয়েছে?

  #### State Management Issues:
  - [ ] Provider properly defined আছে?
  - [ ] ref.watch vs ref.read correctly ব্যবহার হচ্ছে?
  - [ ] State properly update হচ্ছে?
  - [ ] autoDispose causing issues?

  #### UI Issues:
  - [ ] Overflow issues আছে?
  - [ ] Null check করা হয়েছে?
  - [ ] BuildContext valid আছে?
  - [ ] Async gap এ mounted check করা হয়েছে?

  #### Build Issues:
  - [ ] build_runner run করা হয়েছে?
  - [ ] Dependencies up to date?
  - [ ] Flutter clean করা হয়েছে?

  ### Step 3: Debugging Tools
  ```dart
  // Logging
  debugPrint('Debug: $variable');

  // Riverpod debugging
  final ref = ProviderScope(
    observers: [ProviderLogger()],
    child: MyApp(),
  );

  class ProviderLogger extends ProviderObserver {
    @override
    void didUpdateProvider(
      ProviderBase provider,
      Object? previousValue,
      Object? newValue,
      ProviderContainer container,
    ) {
      debugPrint('${provider.name}: $previousValue -> $newValue');
    }
  }
  ```

  ### Step 4: Fix Implementation
  1. Root cause identify করো
  2. Minimal fix implement করো
  3. Side effects check করো
  4. Test লেখো যাতে আবার না হয়

common_errors:
  - error: "type 'Null' is not a subtype of type 'String'"
    cause: "API response এ expected field null আসছে"
    fix: "Model এ nullable type ব্যবহার করো অথবা default value দাও"

  - error: "Bad state: No element"
    cause: "Empty list এ firstWhere/first ব্যবহার করা হচ্ছে"
    fix: "firstWhereOrNull ব্যবহার করো অথবা empty check করো"

  - error: "setState() called after dispose()"
    cause: "Async operation complete হওয়ার পরে widget dispose হয়ে গেছে"
    fix: "mounted check করো setState এর আগে"

  - error: "Provider was disposed but is still being listened to"
    cause: "autoDispose provider still in use"
    fix: "ref.keepAlive() use করো অথবা autoDispose সরাও"
